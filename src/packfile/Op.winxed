// Copyright (C) 2011-2012, Parrot Foundation.

class PACT.Packfile.Op
{
    var operation;
    var results;
    var operands;
    var annotations;
    var labels;

    function Op(string name)
    {
        self.operation = name;
        self.results = [];
        self.operands = [];
        self.annotations = {};
        self.labels = [];
    }

    // BCG: Not sure if results and operands can be separated sanely in
    // all instances.
    function add_results(var results [slurpy])
    {
        for (var r in results)
            push(self.results, r);
    }

    function add_operands(var operands [slurpy])
    {
        for (var o in operands) {
            push(self.operands, o);
        }
    }

    function add_annotation(string name, string value)
    {
        self.annotations[name] = value;
    }

    function add_label(var label)
    {
        push(self.labels, label);
    }

    // BCG: We probably want an inverse of this method as well
    // BCG: I would probably also do this as a stage rather than
    //      put the guts in this class.  See docs/stages.mkd
    function get_opcode_pmc()
    {
        // TODO: Create and return a representation of this op expressed in
        // terms of Parrot Opcode PMCs and raw argument arrays
    }
}
