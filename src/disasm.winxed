/* Basic disassembler to explore the Packfile PMCs */

namespace PACT {
	class Packfile {
		// PBC header
		var header;

		// Segment names
		var annotations_name;
		var bytecode_name;
		var constants_name;
		var debug_name;

		// Annotations
		var annotations;

		// Constants
		var nums;
		var pmcs;
		var strings;
		var subs;

		// Debug mappings
		var debug_files;
		var debug_lines;

		// Bytecode information
		var oplibs;
		var opmap;
		var bytecode;

		function Packfile(var packfile) {
			// Often used variable
			int size, i;

			if ( packfile instanceof 'String' ) {
				string name = packfile;
				packfile = new 'Packfile';
				var file = open(name);
				file.encoding('binary');
				packfile.unpack(string(file.readall()));
				file.close();
			}

			if ( !(packfile instanceof 'Packfile') )
				die("Need a PBC filename or Packfile PMC");

			// Extract header information
			var header;
			self.header = header = new 'Hash';
			for ( string key in [
					'wordsize', 'byteorder', 'fptype', 'uuid_type',
					'version_major', 'version_minor', 'version_patch',
					'bytecode_major', 'bytecode_minor'
					] )
				header[key] = int(packfile[key]);
			header['uuid'] = string(packfile['uuid']);

			// Segments
			var annotations;
			var bytecode;
			var constants;
			var debug;

			// Find the segments
			var directory = packfile.get_directory();
			for ( string name in directory ) {
				var segment = directory[name];
				switch (typeof(segment)) {
				case 'PackfileAnnotations':
					if ( annotations != null )
						die("Got more than one annotation segment");
					self.annotations_name = name;
					annotations = segment;
					break;
				case 'PackfileBytecodeSegment':
					if ( bytecode != null )
						die("Got more than one bytecode segment");
					self.bytecode_name = name;
					bytecode = segment;
					break;
				case 'PackfileConstantTable':
					if ( constants != null )
						die("Got more than one constant table");
					self.constants_name = name;
					constants = segment;
					break;
				case 'PackfileDebug':
					if ( debug != null )
						die("Got more than one debug segment");
					self.debug_name = name;
					debug = segment;
					break;
				default:
					string type = typeof(segment);
					die("Unknown bytecode segment type: " + type);
				}
			}

			// Load annotations
			// TODO: Don't just hang onto the PackfileAnnotation
			if (annotations != null) {
				size = elements(annotations);
				var annos = new 'FixedPMCArray'(size);
				self.annotations = annos;
				for (i = 0; i < size; ++i)
					annos[i] = annotations[i];
			}

			// Load constants
			size = constants.num_count();
			var nums = new 'FixedFloatArray'(size);
			self.nums = nums;
			for (i = 0; i < size; ++i)
				nums[i] = float(constants[i]);

			size = constants.pmc_count();
			var pmcs = new 'FixedPMCArray'(size);
			var subs = [];
			self.pmcs = pmcs;
			self.subs = subs;
			for (i = 0; i < size; ++i) {
				var c = var(constants[i]);
				pmcs[i] = c;
				if (c instanceof 'Sub')
					push(subs, c);
			}
			// Make sure the subs are sorted according to the code offsets
			subs.sort(function(a, b) {
				int a_i = a.start_offs();
				int b_i = b.start_offs();
				if (a_i == b_i) return 0;
				if (a_i < b_i) return -1;
				return 1;
			});

			size = constants.str_count();
			var strings = new 'FixedStringArray'(size);
			self.strings = strings;
			for (i = 0; i < size; ++i)
				strings[i] = string(constants[i]);

			// Load debug mappings
			size = debug;
			var debug_files = new 'FixedStringArray'(size);
			var debug_lines = new 'FixedIntegerArray'(size);
			self.debug_files = debug_files;
			self.debug_lines = debug_lines;
			for (i = 0; i < size; ++i) {
				debug_files[i] = string(debug[i]);
				debug_lines[i] = int(debug[i]);
			}

			// Opmap
			var opmap = bytecode.opmap();
			size = opmap;
			var map = new 'FixedPMCArray'(size);
			self.opmap = map;
			for (i = 0; i < size; ++i) {
				string name = opmap[i];
				map[i] = opmap[name];
			}
			self.oplibs = opmap.oplibs();

			// Bytecode
			size = elements(bytecode);
			var ops = new 'FixedIntegerArray'(size);
			self.bytecode = ops;
			for (i = 0; i < size; ++i)
				ops[i] = bytecode[i];
		}
	}
}

function print_header(var packfile) {
	var info = packfile.header;

	say( 'Core Version    : ', info['version_major'], '.',
			info['version_minor'], '.', info['version_patch'] );
	say( 'Bytecode Version: ', info['bytecode_major'],
			'.', info['bytecode_minor'] );
	say( 'UUID (type ', info['uuid_type'], ')   : ', info['uuid'] );
	say( 'Wordsize ', info['wordsize'],
			'  Byteorder ', info['byteorder'],
			'  Floattype ', info['fptype'] );
}

// TODO: See if there is an include file for these already.
const int
	TYPE_INT = 0,
	TYPE_STR = 1,
	TYPE_PMC = 2,
	TYPE_NUM = 3,
	TYPE_MASK  = 0x0F,

	TYPE_CONST     = 0x0010,
	TYPE_KEYED     = 0x0020, // :flatten or :slurpy
	TYPE_OPTIONAL  = 0x0080,
	TYPE_OPT_FLAG  = 0x0100,
	TYPE_NAME      = 0x0200,
	TYPE_LOOKAHEAD = 0x0400,
	TYPE_INVOCANT  = 0x0800,
	TYPE_CALL_SIG  = 0x1000;

function print_arg(var packfile, int type, int arg, int pc, int had_named) {
	int cons = type & TYPE_CONST;
	int keyd = type & TYPE_KEYED;
	int named = type & TYPE_NAME;
	int is_optional = type & TYPE_OPTIONAL;
	int is_opt_flag = type & TYPE_OPT_FLAG;
	type = type & TYPE_MASK;

	if (keyd) print( named ? '{' : '[');

	if (cons) {
		switch (type) {
		case TYPE_INT:
			print(arg);
			break;

		case TYPE_STR:
			string str = packfile.strings[arg];
			string enc = encoding_name(str);
			print( enc, ':"', escape(str), '"' );
			break;

		case TYPE_PMC:
			print('PMC(', arg, ')');
			print_pmc_constant(packfile, arg);
			break;

		case TYPE_NUM:
			string out = packfile.nums[arg];
			if ( indexof(out, '.') < 0 )
				out += '.0';
			print( out );
			break;

		default:
			die( 'Unknown constant type ' + type + ' at PC ' + pc );
		}
	} else {
		string reg;
		switch (type) {
		case TYPE_INT: reg = '$I'; break;
		case TYPE_STR: reg = '$S'; break;
		case TYPE_PMC: reg = '$P'; break;
		case TYPE_NUM: reg = '$N'; break;
		default:
			die( 'Unknown register type ' + type + ' at PC ' + pc );
		}
		print(reg, arg);
	}

	if (is_optional) print("(optional)");
	if (is_opt_flag) print("(opt flag)");
	if (keyd) print(named ? '}' : ']');

	if (!keyd && named && !had_named) return 1, ' => ';
	return 0, ', ';
}

function bytecode_segment(var packfile) {
	int i, size, sub_idx = -1, sub_start_idx, sub_end_idx = -1;
	var current_sub;

	say( '   Oplibs:' );
	var oplibs = packfile.oplibs;
	for (string name in oplibs) {
		var version = oplibs[name].version();
		print( '      ', name, ' ', version[0] );
		size = elements(version);
		for (i = 1; i < size; ++i)
			print( '.', version[i] );
		say();
	}

	say( '   Opmap:' );
	var opmap = packfile.opmap;
	size = elements(opmap);
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', opmap[i], ' ', elements(opmap[i]) );

	say( '   Bytecode:' );
	var bytecode = packfile.bytecode;
	size = elements(bytecode);

	for (i = 0; i < size; ++i) {
		if (i >= sub_end_idx) {
			sub_idx++;
			current_sub = packfile.subs[sub_idx];
			sub_start_idx = current_sub.start_offs();
			sub_end_idx = current_sub.end_offs();
		}
		if (i == sub_start_idx)
			say(sprintf('      Subroutine: %s (%d - %d)',
			            [current_sub, sub_start_idx, sub_end_idx]));

		var op = opmap[bytecode[i]];
		string name = op.family_name();
		print( '      ', sprintf('%3d', [i] ), ': ', name );

		int space = 20 - length(name);
		if ( space <= 0 ) space = 1;
		for (; space > 0; --space)
			print( ' ' );

		int j, args;
		switch (name) {
			case 'set_args':
			case 'get_results':
			case 'get_params':
			case 'set_returns':
				// Loop over FIA const
				var arg_types = packfile.pmcs[bytecode[++i]];
				args = elements(arg_types);

				print( '(' );
				string comma = "";
				int had_named = 0;
				for ( j = 0; j < args; ++j ) {
					++i;
					print(comma);
					:(had_named, comma) = print_arg(packfile, int(arg_types[j]), bytecode[i], i, had_named);
				}
				print( ')' );
				break;

			default:
				args = elements(op);
				for (j = 0; j < args; ++j) {
					++i;
					if ( j > 0 ) print( ', ' );

					print_arg(packfile, int(op[j]), bytecode[i], i, 0);
				}
		}

		say();
	}
}

function print_pmc_constant(var packfile, int i)
{
	var arr = packfile.pmcs;
	var c = arr[i];
	string type = typeof(c);
	print( ' (', type, '): ' );

	if ( c instanceof 'Sub' ) {
		print(sprintf("%s (PC %d - %d)", [c, c.start_offs(), c.end_offs()]));
		// TODO: multi, outer, arity, flags

		return;
	}

	try {
		print(c);
	} catch () {
		print('<Unprintable>');
	}
}

function constant_table(var packfile) {
	var arr;
	int i, size;

	arr = packfile.nums;
	size = elements(arr);
	say( '   ', size, ' numeric constants:' );
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', arr[i] );

	arr = packfile.strings;
	size = elements(arr);
	say( '   ', size, ' string constants:' );
	for (i = 0; i < size; ++i) {
		string s = arr[i];
		say( '      ', i, ' (', encoding_name(s), '): "', escape(s), '"' );
	}

	arr = packfile.pmcs;
	size = elements(arr);
	say( '   ', size, ' PMC constants:' );
	for (i = 0; i < size; ++i) {
		print('      ', i);
		print_pmc_constant(packfile, i);
		say();
	}
}

function debug_segment(var packfile) {
	var debug_files = packfile.debug_files;
	var debug_lines = packfile.debug_lines;
	int size = elements(debug_files);

	say( '   ', size, ' debug mappings:' );
	for (int i = 0; i < size; ++i)
		say( '      ', i, ': ', debug_files[i], ' ', debug_lines[i] );
}

function annotations_segment(var packfile) {
	var annotations = packfile.annotations;
	int size = elements(annotations);

	say( '   ', size, ' annotations:' );
	for (int i = 0; i < size; ++i) {
		var annotation = annotations[i];

		int offset = annotation.get_offset();
		string name = annotation.get_name();
		print( '      ', offset, ' ', name, ': ' );

		int can_get_type;
		${ can can_get_type, annotation, 'get_type' };
		if (can_get_type) {
			switch (annotation.get_type()) {
			case TYPE_INT:
				say(int(annotation));
				break;

			case TYPE_STR:
				string s = annotation;
				say(encoding_name(s), ':"', escape(s), '"' );
				break;

			case TYPE_PMC:
				var val = annotation.get_pmc_value();
				print( '(', typeof(val), '): ' );
				try {
					say(val);
				} catch () {
					say('<Unprintable>');
				}
			}
		} else {
			say("Unknown annotation type");
		}
	}
}

function main[main](var argv) {
	// Process arguments
	string progname = argv[0];
	if (elements(argv) != 2) {
		cry('Usage: ', progname, ' <PBC file>');
		exit(1);
	}
	string filename = argv[1];

	// Get a Packfile
	var packfile;
	try {
		packfile = new PACT.Packfile(filename);
	} catch (e) {
		cry( progname, ': Error reading packfile ', filename );
		cry( e.message );
		for ( string bt in e.backtrace_strings() )
			cry(bt);
		exit(1);
	}

	try {
		print_header(packfile);
		say();
		say('Segments:');
		say(' Constants: ', packfile.constants_name);
		constant_table(packfile);
		say(' Debug: ', packfile.debug_name);
		debug_segment(packfile);
		if (packfile.annotations_name != null) {
			say(' Annotations: ', packfile.annotations_name);
			annotations_segment(packfile);
		}
		say(' Bytecode: ', packfile.bytecode_name);
		bytecode_segment(packfile);
	} catch (e) {
		cry( progname, ': Error during disassembly ', filename );
		cry( e.message );
		for ( string bt in e.backtrace_strings() )
			cry(bt);
		exit(1);
	}
}
