/* Basic disassembler to explore the Packfile PMCs */

namespace PACT {
	class Packfile {
		// PBC header
		var header;

		// Segment names
		var annotations_name;
		var bytecode_name;
		var constants_name;
		var debug_name;

		// Annotations
		var annotations;

		// Constants
		var nums;
		var pmcs;
		var strings;

		// Debug mappings
		var debug_files;
		var debug_lines;

		// Bytecode information
		var oplibs;
		var opmap;
		var bytecode;

		function Packfile(var packfile) {
			// Often used variable
			int size, i;

			if( packfile instanceof 'String' ) {
				string name = packfile;
				packfile = new 'Packfile';
				var file = open(name);
				file.encoding('binary');
				packfile.unpack(string(file.readall()));
				file.close();
			}

			if( !(packfile instanceof 'Packfile') )
				die("Need a PBC filename or Packfile PMC");

			// Extract header information
			var header;
			self.header = header = new 'Hash';
			for( string key in [
					'wordsize', 'byteorder', 'fptype', 'uuid_type',
					'version_major', 'version_minor', 'version_patch',
					'bytecode_major', 'bytecode_minor'
					] )
				header[key] = int(packfile[key]);
			header['uuid'] = string(packfile['uuid']);

			// Segments
			var annotations;
			var bytecode;
			var constants;
			var debug;

			// Find the segments
			var directory = packfile.get_directory();
			for( string name in directory ) {
				var segment = directory[name];
				switch(typeof(segment)) {
				case 'PackfileAnnotations':
					if( annotations != null )
						die("Got more than one annotation segment");
					self.annotations_name = name;
					annotations = segment;
					break;
				case 'PackfileBytecodeSegment':
					if( bytecode != null )
						die("Got more than one bytecode segment");
					self.bytecode_name = name;
					bytecode = segment;
					break;
				case 'PackfileConstantTable':
					if( constants != null )
						die("Got more than one constant table");
					self.constants_name = name;
					constants = segment;
					break;
				case 'PackfileDebug':
					if( debug != null )
						die("Got more than one debug segment");
					self.debug_name = name;
					debug = segment;
					break;
				default:
					string type = typeof(segment);
					die("Unknown bytecode segment type: " + type);
				}
			}

			// Load annotations
			// TODO: Don't just hang onto the PackfileAnnotation
			size = elements(annotations);
			var annos = new 'FixedPMCArray'(size);
			self.annotations = annos;
			for (i = 0; i < size; ++i)
				annos[i] = annotations[i];

			// Load constants
			size = constants.num_count();
			var nums = new 'FixedFloatArray'(size);
			self.nums = nums;
			for (i = 0; i < size; ++i)
				nums[i] = float(constants[i]);

			size = constants.pmc_count();
			var pmcs = new 'FixedPMCArray'(size);
			self.pmcs = pmcs;
			for (i = 0; i < size; ++i)
				pmcs[i] = var(constants[i]);

			size = constants.str_count();
			var strings = new 'FixedStringArray'(size);
			self.strings = strings;
			for (i = 0; i < size; ++i)
				strings[i] = string(constants[i]);

			// Load debug mappings
			size = debug;
			var debug_files = new 'FixedStringArray'(size);
			var debug_lines = new 'FixedIntegerArray'(size);
			self.debug_files = debug_files;
			self.debug_lines = debug_lines;
			for (i = 0; i < size; ++i) {
				debug_files[i] = string(debug[i]);
				debug_lines[i] = int(debug[i]);
			}

			// Opmap
			var opmap = bytecode.opmap();
			size = opmap;
			var map = new 'FixedPMCArray'(size);
			self.opmap = map;
			for (i = 0; i < size; ++i) {
				string name = opmap[i];
				map[i] = opmap[name];
			}
			self.oplibs = opmap.oplibs();

			// Bytecode
			size = elements(bytecode);
			var ops = new 'FixedIntegerArray'(size);
			self.bytecode = ops;
			for (i = 0; i < size; ++i)
				ops[i] = bytecode[i];
		}
	}
}

function print_header(var packfile) {
	var info = packfile.header;

	say( 'Core Version    : ', info['version_major'], '.',
			info['version_minor'], '.', info['version_patch'] );
	say( 'Bytecode Version: ', info['bytecode_major'],
			'.', info['bytecode_minor'] );
	say( 'UUID (type ', info['uuid_type'], ')   : ', info['uuid'] );
	say( 'Wordsize ', info['wordsize'],
			'  Byteorder ', info['byteorder'],
			'  Floattype ', info['fptype'] );
}

// TODO: See if there is an include file for these already.
const int
    TYPE_INT = 0,
    TYPE_STR = 1,
    TYPE_PMC = 2,
    TYPE_NUM = 3,
    TYPE_CONST = 0x10,
    TYPE_KEYED = 0x20;

function print_arg(var packfile, int type, int arg, int pc) {
	int cons = type & TYPE_CONST;
	int keyd = type & TYPE_KEYED;
	type = type & ~(TYPE_CONST | TYPE_KEYED);

	if(keyd) print( '[' );

	if(cons) {
		switch(type) {
		case TYPE_INT:
			print(arg);
			break;

		case TYPE_STR:
			string str = packfile.strings[arg];
			string enc = encoding_name(str);
			print( enc, ':"', escape(str), '"' );
			break;

		case TYPE_PMC:
			print('PMC(', arg, ')');
			break;

		case TYPE_NUM:
			print(packfile.nums[arg]);
			break;

		default:
			die( 'Unknown constant type ' + type + ' at PC ' + pc );
		}
	} else {
		string reg;
		switch(type) {
		case TYPE_INT: reg = '$I'; break;
		case TYPE_STR: reg = '$S'; break;
		case TYPE_PMC: reg = '$P'; break;
		case TYPE_NUM: reg = '$N'; break;
		default:
			die( 'Unknown register type ' + type + ' at PC ' + pc );
		}
		print(reg, arg);
	}

	if(keyd) print( ']' );
}

function bytecode_segment(var packfile) {
	int i, size;

	say( '   Oplibs:' );
	var oplibs = packfile.oplibs;
	for (string name in oplibs) {
		var version = oplibs[name].version();
		print( '      ', name, ' ', version[0] );
		size = elements(version);
		for(i = 1; i < size; ++i)
			print( '.', version[i] );
		say();
	}

	say( '   Opmap:' );
	var opmap = packfile.opmap;
	size = elements(opmap);
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', opmap[i], ' ', elements(opmap[i]) );

	say( '   Bytecode:' );
	var bytecode = packfile.bytecode;
	size = elements(bytecode);

	for(i = 0; i < size; ++i) {
		var op = opmap[bytecode[i]];
		string name = op.family_name();
		print( '      ', sprintf('%3d', [i] ), ': ', name );

		int space = 20 - length(name);
		if( space <= 0 ) space = 1;
		for(; space > 0; --space)
			print( ' ' );

		int j, args;
		switch(name) {
			case 'set_args':
			case 'get_results':
			case 'get_params':
			case 'set_returns':
				// Loop over FIA const
				var arg_types = packfile.pmcs[bytecode[++i]];
				args = elements(arg_types);

				print( '(' );
				for( j = 0; j < args; ++j ) {
					++i;
					if( j > 0 ) print( ', ' );

					print_arg(packfile, int(arg_types[j]), bytecode[i], i);
				}
				print( ')' );
				break;

			default:
				args = elements(op);
				for(j = 0; j < args; ++j) {
					++i;
					if( j > 0 ) print( ', ' );

					print_arg(packfile, int(op[j]), bytecode[i], i);
				}
		}

		say();
	}
}

function constant_table(var packfile) {
	var arr;
	int i, size;

	arr = packfile.nums;
	size = elements(arr);
	say( '   ', size, ' numeric constants:' );
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', arr[i] );

	arr = packfile.strings;
	size = elements(arr);
	say( '   ', size, ' string constants:' );
	for (i = 0; i < size; ++i) {
		string s = arr[i];
		say( '      ', i, ' (', encoding_name(s), '): "', escape(s), '"' );
	}

	arr = packfile.pmcs;
	size = elements(arr);
	say( '   ', size, ' PMC constants:' );
	for (i = 0; i < size; ++i) {
		var c = arr[i];
		string type = typeof(c);
		print( '      ', i, ' (', type, '): ' );
		try {
			say(c);
		} catch () {
			say('<Unprintable>');
		}
	}
}

function debug_segment(var packfile) {
	var debug_files = packfile.debug_files;
	var debug_lines = packfile.debug_lines;
	int size = elements(debug_files);

	say( '   ', size, ' debug mappings:' );
	for (int i = 0; i < size; ++i)
		say( '      ', i, ': ', debug_files[i], ' ', debug_lines[i] );
}

function annotations_segment(var packfile) {
	var annotations = packfile.annotations;
	int size = elements(annotations);

	say( '   ', size, ' annotations:' );
	for (int i = 0; i < size; ++i) {
		var annotation = annotations[i];
		int offset = annotation.get_offset();
		string name = annotation.get_name();
		// XXX: No way to determine value type
		say( '      ', offset, ': ', name );
	}
}

function main[main](var argv) {
	// Process arguments
	string progname = argv[0];
	if (int(argv) != 2) {
		cry('Usage: ', progname, ' <PBC file>');
		exit(1);
	}
	string filename = argv[1];

	// Get a Packfile
	var packfile;
	try {
		packfile = new PACT.Packfile(filename);
	} catch (e) {
		cry( progname, ': Error reading packfile ', filename );
		cry(e);
		exit(1);
	}

	print_header(packfile);
	say();
	say(packfile.constants_name);
	constant_table(packfile);
	say(packfile.debug_name);
	debug_segment(packfile);
	say(packfile.annotations_name);
	annotations_segment(packfile);
	say(packfile.bytecode_name);
	bytecode_segment(packfile);
}
