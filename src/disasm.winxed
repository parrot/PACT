/* Basic disassembler to explore the Packfile PMCs */

namespace PACT {
	class Packfile {
		// PBC header
		var header;

		// Segment names
		var annotations_name;
		var bytecode_name;
		var constants_name;
		var debug_name;

		// Annotations
		var annotations;

		// Constants
		var nums;
		var pmcs;
		var strings;

		// Debug mappings
		var debug_files;
		var debug_lines;

		// Bytecode information
		var opmap;
		var bytecode;

		function Packfile(var packfile) {
			// Often used variable
			int size, i;

			if( packfile instanceof 'String' ) {
				string name = packfile;
				packfile = new 'Packfile';
				var file = open(name);
				file.encoding('binary');
				packfile.unpack(string(file.readall()));
				file.close();
			}

			if( !(packfile instanceof 'Packfile') )
				die("Need a PBC filename or Packfile PMC");

			// Extract header information
			var header;
			self.header = header = new 'Hash';
			for( string key in [
					'wordsize', 'byteorder', 'fptype', 'uuid_type',
					'version_major', 'version_minor', 'version_patch',
					'bytecode_major', 'bytecode_minor'
					] )
				header[key] = int(packfile[key]);
			header['uuid'] = string(packfile['uuid']);

			// Segments
			var annotations;
			var bytecode;
			var constants;
			var debug;

			// Find the segments
			var directory = packfile.get_directory();
			for( string name in directory ) {
				var segment = directory[name];
				switch(typeof(segment)) {
				case 'PackfileAnnotations':
					if( annotations != null )
						die("Got more than one annotation segment");
					self.annotations_name = name;
					annotations = segment;
					break;
				case 'PackfileBytecodeSegment':
					if( bytecode != null )
						die("Got more than one bytecode segment");
					self.bytecode_name = name;
					bytecode = segment;
					break;
				case 'PackfileConstantTable':
					if( constants != null )
						die("Got more than one constant table");
					self.constants_name = name;
					constants = segment;
					break;
				case 'PackfileDebug':
					if( debug != null )
						die("Got more than one debug segment");
					self.debug_name = name;
					debug = segment;
					break;
				default:
					string type = typeof(segment);
					die("Unknown bytecode segment type: " + type);
				}
			}

			// Load annotations
			// TODO: Don't just hang onto the PackfileAnnotation
			size = elements(annotations);
			var annos = new 'FixedPMCArray'(size);
			self.annotations = annos;
			for (i = 0; i < size; ++i)
				annos[i] = annotations[i];

			// Load constants
			size = constants.num_count();
			var nums = new 'FixedFloatArray'(size);
			self.nums = nums;
			for (i = 0; i < size; ++i)
				nums[i] = float(constants[i]);

			size = constants.pmc_count();
			var pmcs = new 'FixedPMCArray'(size);
			self.pmcs = pmcs;
			for (i = 0; i < size; ++i)
				pmcs[i] = var(constants[i]);

			size = constants.str_count();
			var strings = new 'FixedStringArray'(size);
			self.strings = strings;
			for (i = 0; i < size; ++i)
				strings[i] = string(constants[i]);

			// Load debug mappings
			size = debug;
			var debug_files = new 'FixedStringArray'(size);
			var debug_lines = new 'FixedIntegerArray'(size);
			self.debug_files = debug_files;
			self.debug_lines = debug_lines;
			for (i = 0; i < size; ++i) {
				debug_files[i] = string(debug[i]);
				debug_lines[i] = int(debug[i]);
			}

			// Opmap
			var opmap = bytecode.opmap();
			size = opmap;
			var map = new 'FixedStringArray'(size);
			self.opmap = map;
			for (i = 0; i < size; ++i)
				map[i] = opmap[i];

			// Bytecode
			size = elements(bytecode);
			var ops = new 'FixedIntegerArray'(size);
			self.bytecode = ops;
			for (i = 0; i < size; ++i)
				ops[i] = bytecode[i];
		}
	}
}

function print_header(var packfile) {
	var info = packfile.header;

	say( 'Core Version    : ', info['version_major'], '.',
			info['version_minor'], '.', info['version_patch'] );
	say( 'Bytecode Version: ', info['bytecode_major'],
			'.', info['bytecode_minor'] );
	say( 'UUID (type ', info['uuid_type'], ')   : ', info['uuid'] );
	say( 'Wordsize ', info['wordsize'],
			'  Byteorder ', info['byteorder'],
			'  Floattype ', info['fptype'] );
}

function bytecode_segment(var packfile) {
	say( '   Opmap:' );
	// XXX: PMCs missing oplib information
	var opmap = packfile.opmap;
	int i, size = elements(opmap);
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', opmap[i] );

	// TODO: disassemble integers into bytecode information
	// XXX: Useful information in op_info_table, missing from PMCs
	//  - opcount, types, jump
	say( '   Bytecode:' );
	print( '      ' );
	var bytecode = packfile.bytecode;
	size = elements(bytecode);
	if( size > 0 )
		print( bytecode[0] );
	for (i = 1; i < size; ++i)
		print( ', ', bytecode[i] );
	say();
}

function constant_table(var packfile) {
	var arr;
	int i, size;

	arr = packfile.nums;
	size = elements(arr);
	say( '   ', size, ' numeric constants:' );
	for (i = 0; i < size; ++i)
		say( '      ', i, ': ', arr[i] );

	arr = packfile.strings;
	size = elements(arr);
	say( '   ', size, ' string constants:' );
	for (i = 0; i < size; ++i) {
		string s = arr[i];
		say( '      ', i, ' (', encoding_name(s), '): "', escape(s), '"' );
	}

	arr = packfile.pmcs;
	size = elements(arr);
	say( '   ', size, ' PMC constants:' );
	for (i = 0; i < size; ++i) {
		var c = arr[i];
		string type = typeof(c);
		print( '      ', i, ' (', type, '): ' );
		try {
			say(c);
		} catch () {
			say('<Unprintable>');
		}
	}
}

function debug_segment(var packfile) {
	var debug_files = packfile.debug_files;
	var debug_lines = packfile.debug_lines;
	int size = elements(debug_files);

	say( '   ', size, ' debug mappings:' );
	for (int i = 0; i < size; ++i)
		say( '      ', i, ': ', debug_files[i], ' ', debug_lines[i] );
}

function annotations_segment(var packfile) {
	var annotations = packfile.annotations;
	int size = elements(annotations);

	say( '   ', size, ' annotations:' );
	for (int i = 0; i < size; ++i) {
		var annotation = annotations[i];
		int offset = annotation.get_offset();
		string name = annotation.get_name();
		// XXX: No way to determine value type
		say( '      ', offset, ': ', name );
	}
}

function main[main](var argv) {
	// Process arguments
	string progname = argv[0];
	if (int(argv) != 2) {
		cry('Usage: ', progname, ' <PBC file>');
		exit(1);
	}
	string filename = argv[1];

	// Get a Packfile
	var packfile;
	try {
		packfile = new PACT.Packfile(filename);
	} catch (e) {
		cry( progname, ': Error reading packfile ', filename );
		cry(e);
		exit(1);
	}

	print_header(packfile);
	say();
	say(packfile.constants_name);
	constant_table(packfile);
	say(packfile.debug_name);
	debug_segment(packfile);
	say(packfile.annotations_name);
	annotations_segment(packfile);
	say(packfile.bytecode_name);
	bytecode_segment(packfile);
}
